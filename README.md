# Проект "Система управления личными финансами"


## Требования

### Хранение данных

Данные хранятся в [самостоятельно реализованном аналоге базы данных](./src/Database/Database.java). Данные хранятся в памяти приложения,
а при завершении его работы записываются в файлы. При инициализации приложения начальные данные считываются 
из этих же файлов.

### [Авторизация пользователей](./src/Controllers/UserController.java)

При создании аккаунта создается запись с (логин, пароль) в БД.
При входе в аккаунт в БД ищется введенная комбинация (логин, пароль) и возвращается сгенерированный ключ доступа,
по которому в дальнейшем осуществляется аутентификация. 

### Функционал управления финансами

Соответствующие методы можно найти в [WalletController](./src/Controllers/WalletController.java).
Реализовано добавление доходов и расходов с указанием их категории, а также добавление бюджета для категорий. 

### Работа с кошельком пользователя 

При создании аккаунта создается сущность [User](./src/Models/UserModel.java), для которой создается сущность [Wallet](./src/Models/WalletModel.java). Между ними 
устанавливается связь 1-1, что позволяет реализовать привязку кошелька к пользователю. В сущности Wallet хранятся все данные о доходах, расходах
и установленных бюджетах. 

### Вывод информации

Возможность отображения доходов, расходов, установленных бюджетов и оставшихся лимитов реализовано в [WalletController](./src/Controllers/WalletController.java).
Вернее, там реализованы методы для получения необходимой информации, которая далее отображается в [Client](./src/Client.java) при вызове соответствующих 
пунктов меню. 

### Подсчет расходов и доходов

Как было упомянуто в пункте выше, все методы для получения доходов, расходов, бюджета, оставшихся лимитов реализованы в 
[WalletController](./src/Controllers/WalletController.java). Общие расходы рассчитываются и выводятся в [Client](./src/Client.java)
при выборе соответствующих пунктов меню. Если по заданной категории записей не найдено, пользователь получает соответствующее уведомление. 

### Проверка вводимых данных

Проверка корректности ввода пункта меню реализована в [Client](./src/Client.java). Валидация введенных параметров для вызова методов
реализована на уровне контроллеров ([UserController](./src/Controllers/UserController.java), [WalletController](./src/Controllers/WalletController.java)) 
с последующим пробросом ошибок. Эти ошибки обрабатываются на уровне [Client](./src/Client.java) и выводятся соответствующие сообщения пользователю.

### Оповещения

При добавлении расхода рассчитывается разность доходов и расходов, а также расхода и установленного
бюджета для данной категории. Если расходы превысили доходы или превышен лимит трат
на категорию, пользователь получает соответствующее уведомление. Функционал реализован
в [Client](./src/Client.java) в обработчике, отвечающем за добавление расходов. 

### Сохранение данных

Механизм сохранения данных основан на реализации интерфейса Autocloseable для [Database](./src/Database/Database.java) и [Server](./src/Server.java).
При создании БД в конструкторе вызывается метод, отвечающий за загрузку данных из файлов. При завершении работы приложения (сервера) вызывается 
метод "close", в котором выполняется выгрузка данных в файлы. 

Импорт и экспорт данных из файла и в файл реализованы в [FileManager](./src/utils/FileManager.java). 
Для каждого типа данных был придуман свой xml-подобный формат хранения с целью достижения взаимно-однозначного соответствия 
при преобразовании в строку и парсинге обратно.

За преобразование в строку отвечает метод recursiveStringify. На вход ему могут поступить произвольные данные,
которые последовательно (рекурсивно) превращаются в строку. Для собственных моделей 
([UserModel](./src/Models/UserModel.java), [WalletModel](./src/Models/WalletModel.java), [PaymentModel](./src/Models/PaymentModel.java))
также был реализован метод toString, чтобы была возможность воссоздать данные по результирующей строке. 

За преобразование из строки в структуры данных отвечает метод recursiveParse.
Для корректной трансформации важно учитывать xml-подобную структуру и вложенность элементов.
Для этого метода было предусмотрено внедрение зависимостей (DI) в виде передачи конструкторов для
произвольных типов данных. В нашем случае, такими данными являются модели БД. 
Для каждой модели были созданы фабрики
([PaymentModelFactory](./src/Models/Factories/PaymentModelFactory.java), 
[UserModelFactory](./src/Models/Factories/UserModelFactory.java),
[WalletModelFactory](./src/Models/Factories/WalletModelFactory.java))
, которые используются в recursiveParse 
для построения моделей на основании данных из строки. 

Результирующий формат хранения данных можно посмотреть [здесь](./src/TablesStorage)


### Чтение команд пользователя в цикле

Взаимодействие с пользователем осуществляется через [меню команд в терминале](./src/Client.java).


## Архитектура приложения

Реализовано несколько слоев:
- [Database](./src/Database), [Models](./src/Models)
- [Controllers](./src/Controllers)
- [Router](./src/Router)
- [Server](./src/Server.java)
- [Client](./src/Client.java)

Цепочка их взаимодействия строится снизу-вверх. При этом между собой могут взаимодействовать
только соседние слои. Другими словами, Client -> Server, Server -> Router, Router -> Controllers, Controllers -> (Database, Models).
Также было использовано внедрение зависимостей (DI) для БД. На уровне Server создается экземпляр БД, с которым
ведется работа на последующих слоях. При этом стоит отметить, что Server никак с БД не взаимодействует, 
а лишь использует для инициализации следующих слоев при старте приложения.

## Тесты

Каждый слой приложения (кроме серверного и клиентского) покрыт тестами.

- [DatabaseTester](./src/Database/DatabaseTester.java)
- [ControllerTester](./src/Controllers/ControllerTester.java)
- [RouterTester](./src/Router/RouterTester.java)

Все тесты запускаются в [Tester](./src/Tester.java)